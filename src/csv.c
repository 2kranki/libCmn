// vi:nu:et:sts=4 ts=4 sw=4
/*
 * File:   csv.c
 *	Generated by 06/03/2015 09:39:47
 *
 * Created on December 30, 2014
 */

 
/*
 This is free and unencumbered software released into the public domain.
 
 Anyone is free to copy, modify, publish, use, compile, sell, or
 distribute this software, either in source code form or as a compiled
 binary, for any purpose, commercial or non-commercial, and by any
 means.
 
 In jurisdictions that recognize copyright laws, the author or authors
 of this software dedicate any and all copyright interest in the
 software to the public domain. We make this dedication for the benefit
 of the public at large and to the detriment of our heirs and
 successors. We intend this dedication to be an overt act of
 relinquishment in perpetuity of all present and future rights to this
 software under copyright law.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 
 For more information, please refer to <http://unlicense.org/>
 */




//*****************************************************************
//* * * * * * * * * * * *  Data Definitions   * * * * * * * * * * *
//*****************************************************************

/* Header File Inclusion */
#include    "csv_internal.h"
#include    "ascii.h"
#include    "str.h"



#ifdef	__cplusplus
extern "C" {
#endif
    

    


 
    /****************************************************************
    * * * * * * * * * * *  Internal Subroutines   * * * * * * * * * *
    ****************************************************************/

    //---------------------------------------------------------------
    //                            G e t C h r
    //---------------------------------------------------------------
    
    static
    ERESULT			csv_GetChr(
        CSV_DATA        *cbp,
        char            *pUsrChr
    )
    {
        int             WrkChr;
        
        // Do initialization.
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        if( cbp->flgs & CSV_EOF ) {
			return( ERESULT_EOF_ERROR );
        }
        
        // Read the Character.
        WrkChr = fgetc( cbp->fp );
        if( WrkChr == EOF ) {
            if( feof(cbp->fp) ) {
                cbp->flgs |= CSV_EOF;
                return( ERESULT_EOF_ERROR );
            }
            else
                return( CSV_ERROR_READ );
        }
        if( (WrkChr >= ' ') && (WrkChr < ASCII_DEL) )
            ;
        else if( (WrkChr == ASCII_LF) || (WrkChr == ASCII_CR) )
            ;
        else if( WrkChr == ASCII_CPM_EOF ) {
            cbp->flgs |= CSV_EOF;
            return( ERESULT_EOF_ERROR );
        }
        else if( WrkChr == ASCII_TAB )
            ;
        else {
            /*** Illegal Character ***/
            return( CSV_ERROR_IC );
        }
        
        // Return to caller.
        *pUsrChr = (char)WrkChr;
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    //---------------------------------------------------------------
    //                          G e t D b l
    //---------------------------------------------------------------
    
    static
    ERESULT			csv_GetDbl(
        CSV_DATA        *cbp,
        double			*pDbl
    )
    {
        ERESULT         eRc;
        int             sln = 0;
        char            chr[32];
        char            wrkChr;
        
        // Do initialization.
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Skip leading spaces.
         */
        for( ;; ) {
            eRc = csv_GetChr( cbp, &wrkChr );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
            if( (wrkChr >= ' '+1) && (wrkChr < ASCII_DEL) ) {
                if( sln < 32-1 )
                    chr[sln++] = wrkChr;
                else {
                    /*** String Too Long ***/
                    return( CSV_ERROR_SL );
                }
            }
            else
                break;
        }
        ungetc( wrkChr, cbp->fp );
        chr[sln] = '\0';
        *pDbl = atof( chr );
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    //---------------------------------------------------------------
    //                          G e t I n t
    //---------------------------------------------------------------
    
    static
    ERESULT			csv_GetInt(
        CSV_DATA        *cbp,
        int             *pInteger
    )
    {
        int             num = 0;
        int             sign = 1;
        ERESULT         eRc;
        char            c;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Read in the Integer in Character Format.
         */
        eRc = csv_GetChr( cbp, &c );
        if( ERESULT_HAS_FAILED(eRc) )
            return( eRc );
        if( (c == '+') || (c == '-') ) {
            if( c == '-' )
                sign = -1;
            eRc = csv_GetChr( cbp, &c );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        for( ;; ) {
            if( (c >= '0') && (c <= '9') ) {
                num = (num * 10) + (c - '0');
            }
            else
                break;
            eRc = csv_GetChr( cbp, &c );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        ungetc( c, cbp->fp );
        *pInteger = num * sign;
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          G e t L o g i c a l
    //---------------------------------------------------------------
    
    static
    ERESULT  csv_GetLogical(
        CSV_DATA        *cbp,
        bool            *Log
    )
    {
        char            WrkChr;
        ERESULT         eRc;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Read in the Integer in Character Format.
         */
        eRc = csv_GetChr( cbp, &WrkChr );
        if( ERESULT_HAS_FAILED(eRc) )
            return( eRc );
        if( WrkChr == 'T' ) {
            *Log = true;
        }
        else if( WrkChr == 'F' ) {
            *Log = false;
        }
        else {
            *Log = false;
            /*** Illegal Character ***/
            return( CSV_ERROR_IC );
        }
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          G e t L n g
    //---------------------------------------------------------------
    
    /* Read in a long.
     */
    
    static
    ERESULT     csv_GetLng(
        CSV_DATA    *cbp,
        long        *Integer
    )
    {
        long        num = 0;
        int         sign = 1;
        ERESULT     eRc;
        char        c;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Read in the Integer in Character Format.
         */
        eRc = csv_GetChr( cbp, &c );
        if( ERESULT_HAS_FAILED(eRc) )
            return( eRc );
        if( (c == '+') || (c == '-') ) {
            if( c == '-' )
                sign = -1;
            eRc = csv_GetChr( cbp, &c );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        for( ;; ) {
            if( (c >= '0') && (c <= '9') ) {
                num = (num * 10) + (c - '0');
            }
            else
                break;
            eRc = csv_GetChr( cbp, &c );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        ungetc( c, cbp->fp );
        *Integer = num * sign;
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          G e t S t r
    //---------------------------------------------------------------
    
    /* Read in a character string.
     */
    
    static
    ERESULT         csv_GetStr(
        CSV_DATA        *cbp,
        char            *chr,
        short           max
    )
    {
        size_t          len = 0;
        char            trm = ',';
        ERESULT         eRc;
        char            c;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Read in the String.
         */
        eRc = csv_GetChr( cbp, &c );
        if( ERESULT_HAS_FAILED(eRc) )
            return( eRc );
        if( c == '"' ) {
            trm = '"';
            eRc = csv_GetChr( cbp, &c );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        for( ;; ) {
            if( c == trm )
                break;
            else if( ((c >= ' ') && (c < ASCII_DEL)) || (c == '\t') ) {
                if( len < max )
                    chr[len++] = (char)c;
                else {
                    /*** String Too Long ***/
                    return( CSV_ERROR_SL );
                }
            }
            else
                break;
            eRc = csv_GetChr( cbp, &c );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        for( ; (len < max+1); )
            chr[len++] = '\0';
        
        /* Validate the field terminator.
         */
        if( trm == ',' ) {
            ungetc( c, cbp->fp );
        }
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                 I n t e r n a l C l o s e
    //---------------------------------------------------------------
    
#ifdef XYZZY
    static
    ERESULT         csv_InternalClose(
        CSV_DATA        *cbp,
        bool            fDelete
    )
    {
        ERESULT          eRc = ERESULT_SUCCESSFUL_COMPLETION;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Write the file EOF for stream files.
         */
        if( cbp->rcdLen )
            ;
        else {
            if( cbp->fp && (cbp->flgs & CSV_ADD) ) {
                fseek( cbp->fp, 0L, SEEK_END );
                (void)csv_PutChr( cbp, ASCII_CPM_EOF );
            }
        }
        
        /* Close the file if necessary.
         */
        if( cbp->fp ) {
            (void)fclose( cbp->fp );
            cbp->fp = NULL;
            cbp->flgs &= ~CSV_OPEN;
            if( fDelete ) {
                if( cbp->fn ) {
#ifdef  __BCOS2__
                    (void)remove( cbp->fn );
#endif
#ifdef  __IBMCS2__
                    (void)remove( cbp->fn );
#endif
#ifdef  __MSC__
                    (void)unlink( cbp->fn );
#endif
                }
            }
        }
        
        /* Free the buffer.
         */
        if( cbp->bf ) {
            mem_Free( cbp->bf );
            cbp->bf = NULL;
        }
        
        /* Free the main control block.
         */
        if( cbp->fn ) {
            mem_Free( cbp->fn );
            cbp->fn = NULL;
        }
        
        /* Free the main control block.
         */
        mem_Free( cbp );
        cbp = NULL;
        
        /* Return to caller.
         */
        return( eRc );
    }
#endif
    
    
    
    
    //---------------------------------------------------------------
    //                  I n t e r n a l O p e n
    //---------------------------------------------------------------
    
#ifdef XYZZY
    static
    ERESULT         csv_InternalOpen(
        CSV_DATA        *cbp,
        char            *fn,
        uint16_t        rs,
        uint16_t        bs,
        bool            lock,
        uint16_t        pack,
        uint16_t        numFields,
        CSV_FIELD       *fa,
        bool            fCreate
    )
    {
        uint32_t        i;
        
        /* Validate the input parameters.
         */
        if( (pack == 1) || (pack == 2) || (pack == 4) )
            ;
        else
            return( ERESULT_INVALID_PARAMETER );
        
        /* Allocate virtual array control block
         */
        //FIXME: cbp = (csv_CB *)mem_Malloc( 1, (sizeof(csv_CB)+((nf-1)*sizeof(CSV_FIELD))) );
        if(cbp == NULL)
            return( ERESULT_INSUFFICIENT_MEMORY );
        
        /* Initialize the fields.
         */
        cbp->pack = pack;
        cbp->rcdLen = rs;
        cbp->bufLen = bs;
        
        /* Open the file.
         */
        if( fCreate ) {
            cbp->fp = fopen( fn, "wb+" );
            if( cbp->fp == NULL ) {
                (void)csv_InternalClose( cbp, fCreate );
                return( ERESULT_OPEN_ERROR );
            }
            else {
                cbp->flgs |= CSV_EOF;
            }
        }
        else {
            cbp->fp = fopen( fn, "rb+" );
            if( cbp->fp == NULL ) {
                (void)csv_InternalClose( cbp, fCreate );
                return( ERESULT_OPEN_ERROR );
            }
        }
        cbp->flgs |= CSV_OPEN;
        cbp->fn = (char *)mem_Malloc( strlen(fn)+1 );
        if( cbp->fn == NULL ) {
            (void)csv_InternalClose( cbp, fCreate );
            return( ERESULT_INSUFFICIENT_MEMORY );
        }
        strcpy( cbp->fn, fn );
        
        /* Set up the data buffer if requested.
         */
        if( bs ) {
            if( (cbp->bf = (char *)mem_Malloc( bs )) == NULL ) {
                (void)csv_InternalClose( cbp, fCreate );
                return( ERESULT_INSUFFICIENT_MEMORY );
            }
            if( setvbuf( cbp->fp, cbp->bf, _IOFBF, bs ) ) {
                (void)csv_InternalClose( cbp, fCreate );
                return( ERESULT_INSUFFICIENT_MEMORY );
            }
        }
        
        /* Copy the record field descriptors.
         */
        cbp->numfld = numFields;
        for( i=0; i<numFields; ++i ) {
            memcpy( &cbp->fa[i], fa++, sizeof(CSV_FIELD) );
        }
        
        /* Return to caller.
         */
        if( lock )                      /* Dummied up for Borland C++ */
            i = 0;
        //*UserCbp = cbp;
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
#endif
    
    
    
    
    //---------------------------------------------------------------
    //                          P u t C h r
    //---------------------------------------------------------------
    
    ERESULT         csv_PutChr(
        CSV_DATA        *cbp,
        int             chr
    )
    {
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        if( (chr >= ' ') && (chr < ASCII_DEL) )
            ;
        else if( (chr == ASCII_LF) || (chr == ASCII_CR) || (chr == ASCII_CPM_EOF) )
            ;
        else {
            /*** Illegal Character ***/
            return( CSV_ERROR_IC );
        }
        
        /* Write the Character.
         */
        if( fputc( chr, cbp->fp ) == chr )
            ++cbp->lenrcd;
        else {
            /*** Write Error ***/
            return( CSV_ERROR_WRITE );
        }
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          P u t D b l
    //---------------------------------------------------------------
    
    static
    ERESULT         csv_PutDbl(
        CSV_DATA        *this,
        double          *dbl,
        short           len,
        short           dec
    )
    {
        //int             cln;
        ERESULT         eRc;
        char            *chr;
        char            FmtBuf[64];
        char            StrBuf[64];
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( this ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Format the number to character form.
         */
        //  We could not use the following, because IBM C Set/2 does not
        //  support the "*" in the format for width or precision.
        //  sprintf( StrBuf, "%-*.*f", (int)len, (int)dec, *dbl );
        sprintf( FmtBuf, "%%-%d.%df", (int)len, (int)dec );
        sprintf( StrBuf, FmtBuf, *dbl );
        chr = StrBuf;
#ifdef  __APPLE__
        //chr = fcvt( *dbl, dec, &numdig, &sign );
#endif
#ifdef  __IBMCS2__
        chr = _fcvt( *dbl, dec, &numdig, &sign );
#endif
#ifdef  __MSC__
        chr = fcvt( *dbl, dec, &numdig, &sign );
#endif
        
        /* Write out the number.
         */
#ifdef  XXX
        cln = strlen( chr );
        for( i=0; i<numdig; ++i ) {
            eRc = csv_PutChr( cbp, chr[i] );
            if( ERESULT_FAILURE(eRc) )
                return( eRc );
        }
        rc = csv_PutChr( cbp, '.' );
        if( rc )
            return( rc );
        for( ; i<cln; ++i ) {
            eRc = csv_PutChr( cbp, chr[i] );
            if( ERESULT_FAILURE(eRc) )
                return( eRc );
        }
#endif
        chr = StrBuf;
        while( *chr == ' ' )
            ++chr;
        if( *chr ) {
            while( *chr ) {
                if( *chr == ' ' )
                    break;
                eRc = csv_PutChr( this, *chr );
                if( ERESULT_HAS_FAILED(eRc) )
                    return( eRc );
                ++chr;
            }
        }
        else {
            eRc = csv_PutChr( this, '0' );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          P u t I n t
    //---------------------------------------------------------------
    
    static
    ERESULT         csv_PutInt(
        CSV_DATA        *cbp,
        int             *lng
    )
    {
        int             i;
        size_t          len;
        char            chr[32];
        ERESULT         eRc;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Write out the number.
         */
        sprintf( chr, "%d", *lng );
        len = str_LengthA( chr );
        for( i=0; i<len; ++i ) {
            if( chr[i] == ' ' )
                continue;
            eRc = csv_PutChr( cbp, chr[i] );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          P u t L n g
    //---------------------------------------------------------------
    
    /* Write a long integer.
     */
    
    static ERESULT  csv_PutLng(
        CSV_DATA        *cbp,
        long            *lng
    )
    {
        int             i;
        size_t          len;
        char            chr[32];
        ERESULT         eRc;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Write out the number.
         */
        sprintf( chr, "%ld", *lng );
        len = str_LengthA( chr );
        for( i=0; i<len; ++i ) {
            if( chr[i] == ' ' )
                continue;
            eRc = csv_PutChr( cbp, chr[i] );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          P u t S t r
    //---------------------------------------------------------------
    
    /* Write a character string.
     */
    
    static ERESULT  csv_PutStr(
        CSV_DATA        *cbp,
        char            *pChr,
        short           max
    )
    {
        int             i;
        size_t          len = str_LengthA( pChr );
        bool            dl = false;
        ERESULT         eRc;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        if( len > max ) {
            /*** String is Too Big. ***/
            return( CSV_ERROR_SL );
        }
        
        /* Write the Character String.
         */
        if( strchr( pChr, ',' ) == NULL )
            ;
        else
            dl = true;
        if( (*pChr == ' ') || (*pChr == '\t') )
            dl = true;
        if( dl ) {
            eRc = csv_PutChr( cbp, '"' );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        for( i=0; i<len; ++i ) {
            eRc = csv_PutChr( cbp, pChr[i] );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        if( dl ) {
            eRc = csv_PutChr( cbp, '"' );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        }
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                      S k i p C r L f
    //---------------------------------------------------------------
    
    static
    ERESULT         csv_SkipCrLf(
        CSV_DATA        *cbp
    )
    {
        ERESULT         eRc;
        char            WrkChr;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Skip leading spaces.
         */
        do {
            eRc = csv_GetChr( cbp, &WrkChr );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        } while( (WrkChr == ASCII_LF) || (WrkChr == ASCII_CR) );
        ungetc( WrkChr, cbp->fp );
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                      S k i p S p a c e s
    //---------------------------------------------------------------
    
    static
    ERESULT         csv_SkipSpaces(
        CSV_DATA        *cbp
    )
    {
        ERESULT         eRc;
        char            WrkChr;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        
        /* Skip leading spaces.
         */
        do {
            eRc = csv_GetChr( cbp, &WrkChr );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
        } while( (WrkChr == ' ') || (WrkChr == '\t') );
        ungetc( WrkChr, cbp->fp );
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    



    /****************************************************************
    * * * * * * * * * * *  External Subroutines   * * * * * * * * * *
    ****************************************************************/


    //===============================================================
    //                      *** Class Methods ***
    //===============================================================

    CSV_DATA *     csv_Alloc(
        uint16_t        numFields
    )
    {
        CSV_DATA        *cbp;
        uint32_t        cbSize = sizeof(CSV_DATA);
        
        // Do initialization.
        
        if (0 == numFields) {
            numFields = 16;
        }
        cbp = obj_Alloc( cbSize + (numFields * sizeof(CSV_FIELD)) );
        obj_setMisc1(cbp, numFields);
        
        // Return to caller.
        return( cbp );
    }



    

    //===============================================================
    //                      P r o p e r t i e s
    //===============================================================

    uint16_t        csv_getPriority(
        CSV_DATA     *cbp
    )
    {

        // Validate the input parameters.
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif

        //return cbp->priority;
        return 0;
    }

    bool            csv_setPriority(
        CSV_DATA     *cbp,
        uint16_t        value
    )
    {
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        //cbp->priority = value;
        return true;
    }



    uint32_t        csv_getSize(
        CSV_DATA       *cbp
    )
    {
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
        }
#endif
        return( 0 );
    }




    

    //===============================================================
    //                          M e t h o d s
    //===============================================================


    //---------------------------------------------------------------
    //                        D e a l l o c
    //---------------------------------------------------------------

    void            csv_Dealloc(
        OBJ_ID          objId
    )
    {
        CSV_DATA   *cbp = objId;
        bool            fRc;

        // Do initialization.
        if (NULL == cbp) {
            return;
        }        
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
            return;
        }
#endif

        fRc = csv_Disable( cbp );

        obj_Dealloc( cbp );
        cbp = NULL;

        // Return to caller.
    }



    //---------------------------------------------------------------
    //                      D i s a b l e
    //---------------------------------------------------------------

    bool            csv_Disable(
        CSV_DATA		*cbp
    )
    {

        // Do initialization.
        if (NULL == cbp) {
            return false;
        }
    #ifdef NDEBUG
    #else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
            return false;
        }
    #endif

        // Put code here...

        obj_Disable(cbp);
        
        // Return to caller.
        return true;
    }



    //---------------------------------------------------------------
    //                          E n a b l e
    //---------------------------------------------------------------

    bool            csv_Enable(
        CSV_DATA		*cbp
    )
    {

        // Do initialization.
    #ifdef NDEBUG
    #else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
            return false;
        }
    #endif
        
        obj_Enable(cbp);

        // Put code here...
        
        // Return to caller.
        return true;
    }



    //---------------------------------------------------------------
    //                          I n i t
    //---------------------------------------------------------------

    CSV_DATA *   csv_Init(
        CSV_DATA       *cbp
    )
    {
        
        if (OBJ_NIL == cbp) {
            return OBJ_NIL;
        }
        
        cbp = obj_Init( cbp, obj_getSize(cbp), OBJ_IDENT_CSV );
        if (OBJ_NIL == cbp) {
            return OBJ_NIL;
        }
        obj_setVtbl(cbp, (OBJ_IUNKNOWN *)&csv_Vtbl);
        
        //cbp->stackSize = obj_getMisc1(cbp);

    #ifdef NDEBUG
    #else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
            return OBJ_NIL;
        }
        //BREAK_NOT_BOUNDARY4(&cbp->thread);
    #endif

        return cbp;
    }

     

    //---------------------------------------------------------------
    //                       I s E n a b l e d
    //---------------------------------------------------------------
    
    bool            csv_IsEnabled(
        CSV_DATA        *cbp
    )
    {
        
        // Do initialization.
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
            return false;
        }
#endif
        
        if (obj_IsEnabled(cbp))
            return true;
        
        // Return to caller.
        return false;
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          R e a d
    //---------------------------------------------------------------
    
    /* csv_Read() reads in the next record using the record desription
     * provided to csv_Open() or csv_Create().
     */
    
    ERESULT         csv_Read(
        CSV_DATA        *cbp,
        short           rn,
        void            *data
    )
    {
        int             i;
        long            off;
        ERESULT         eRc = CSV_ERROR_READ;
        short           Offset = 0; /* Structure Offset for Field */
        char            *DatPtr;    /* Structure Field Pointer */
        char            WrkChr;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
            return false;
        }
#endif
        
        /* Validate the input.
         */
        if( cbp->rcdLen )
            ;
        else {
            if( cbp->flgs & CSV_EOF ) {
                /*** at End-of-File ***/
                return( ERESULT_EOF_ERROR );
            }
        }
        
        /* If a fixed file, position to the record.
         */
        if( cbp->rcdLen ) {
            if( rn <= 0 ) {
                /*** Invalid Record Number ***/
                return( CSV_ERROR_IR );
            }
            off = (rn - 1) * cbp->rcdLen;
            if( fseek( cbp->fp, off, SEEK_SET ) == 0 )
                ;
            else {
                /*** Seek Error ***/
                return( CSV_ERROR_SEEK );
            }
        }
        
        /* Read in the data.
         */
        cbp->lenrcd = 0;
        for( i=0; i<cbp->numfld; ++i ) {

            /* Skip leading white-space.
             */
            eRc = csv_SkipSpaces( cbp );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );

            /* Process the field.
             */
            switch( cbp->fa[i].type ) {
                case    'C':
                    DatPtr = (char *)data + Offset;
                    eRc = csv_GetStr( cbp, (char *)DatPtr, cbp->fa[i].length );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += cbp->fa[i].length + 1;
                    break;
                case    'I':
                    Offset += (Offset % cbp->pack);
                    DatPtr = (char *)data + Offset;
                    eRc = csv_GetInt( cbp, (int *)DatPtr );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += sizeof(int);
                    break;
                case    'L':
                    if( cbp->pack > 1 )
                        Offset += (Offset % 2);
                    DatPtr = (char *)data + Offset;
                    eRc = csv_GetLogical( cbp, (bool *)DatPtr );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += sizeof(short);
                    break;
                case    'D':
                case    'M':
                    Offset += (Offset % cbp->pack);
                    DatPtr = (char *)data + Offset;
                    eRc = csv_GetLng( cbp, (long *)DatPtr );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += sizeof(long);
                    break;
                case    'N':
                    Offset += (Offset % cbp->pack);
                    DatPtr = (char *)data + Offset;
                    eRc = csv_GetDbl( cbp, (double *)DatPtr );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += sizeof(double);
                    break;
            }

            /* Process trailing white-space.
             */
            eRc = csv_SkipSpaces( cbp );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );

            /* Process field/record terminator.
             */
            eRc = csv_GetChr( cbp, &WrkChr );
            if( ERESULT_HAS_FAILED(eRc) )
                return( eRc );
            if( i == cbp->numfld - 1 ) {
                if( (WrkChr == ASCII_CR) || (WrkChr == ASCII_LF) ) {
                    eRc = csv_SkipCrLf( cbp );
                    if( eRc == ERESULT_EOF_ERROR )
                        ;
                    else if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                }
                else
                    return( CSV_ERROR_IC );
            }
            else {
                if( WrkChr == ',' )
                    ;
                else
                    return( CSV_ERROR_IC );
            }
        }
        
        /* Check for EOF.
         */
        if( cbp->flgs & CSV_EOF )
            (void)fseek( cbp->fp, -1L, SEEK_END );
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                          W r i t e
    //---------------------------------------------------------------
    
    /* csv_Write() appends a new record to the file using the record
     * desription provided to csv_Open() or csv_Create().
     */
    
    ERESULT         csv_Write(
        CSV_DATA        *cbp,
        short           rn,         /* Record Number if Fixed File Otherwise 0 */
        void            *data       /* Record Structure Data Pointer */
    )
    {
        int             i;
        char            c;
        ERESULT         eRc = CSV_ERROR_READ;
        short           Offset = 0; /* Structure Offset for Field */
        char            *DatPtr;    /* Structure Field Pointer */
        long            off;
        
        /* Do initialization.
         */
#ifdef NDEBUG
#else
        if( !csv_Validate( cbp ) ) {
            DEBUG_BREAK();
            return false;
        }
#endif
        
        /* Validate the input.
         */
        if( cbp->rcdLen )
            ;
        else {
            if( cbp->flgs & CSV_EOF )
                ;
            else {
                /*** Not at End-of-File ***/
                return( ERESULT_WRITE_ERROR );
            }
        }
        
        /* If a fixed file, position to the record.
         */
        if( cbp->rcdLen ) {
            if( rn <= 0 ) {
                /*** Invalid Record Number ***/
                return( CSV_ERROR_IR );
            }
            off = (rn - 1) * cbp->rcdLen;
            if( fseek( cbp->fp, off, SEEK_SET ) == 0 )
                ;
            else {
                /*** Seek Error ***/
                return( ERESULT_SEEK_ERROR );
            }
        }
        else
            cbp->flgs |= CSV_ADD;
        
        /* Write the data to the file.
         */
        cbp->lenrcd = 0;
        for( i=0; i<cbp->numfld; ++i ) {
            switch( cbp->fa[i].type ) {
                case    'C':
                    DatPtr = (char *)data + Offset;
                    eRc = csv_PutStr( cbp, (char *)DatPtr, cbp->fa[i].length );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += cbp->fa[i].length + 1;
                    break;
                case    'I':
                    Offset += (Offset % cbp->pack);
                    DatPtr = (char *)data + Offset;
                    eRc = csv_PutInt( cbp, (int *)DatPtr );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += sizeof(int);
                    break;
                case    'L':
                    if( cbp->pack > 1 )
                        Offset += (Offset % 2);
                    DatPtr = (char *)data + Offset;
                    if( *((bool *)DatPtr) )
                        c = 'T';
                    else
                        c = 'F';
                    eRc = csv_PutChr( cbp, c );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += sizeof(short);
                    break;
                case    'D':
                case    'M':
                    Offset += (Offset % cbp->pack);
                    DatPtr = (char *)data + Offset;
                    eRc = csv_PutLng( cbp, (long *)DatPtr );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += sizeof(long);
                    break;
                case    'N':
                    Offset += (Offset % cbp->pack);
                    DatPtr = (char *)data + Offset;
                    eRc = csv_PutDbl(
                                    cbp,
                                    (double *)DatPtr,
                                    cbp->fa[i].length,
                                    cbp->fa[i].dec
                                    );
                    if( ERESULT_HAS_FAILED(eRc) )
                        return( eRc );
                    Offset += sizeof(double);
                    break;
            }
            if( i == cbp->numfld-1 )
                ;
            else {
                eRc = csv_PutChr( cbp, ',' );
                if( ERESULT_HAS_FAILED(eRc) )
                    return( eRc );
            }
        }
        
        /* Write filler space if needed.
         */
        if( cbp->rcdLen ) {
            for( ; cbp->lenrcd < cbp->rcdLen-2; ) {
                eRc = csv_PutChr( cbp, ' ' );
                if( ERESULT_HAS_FAILED(eRc) )
                    return( eRc );
            }
        }
        
        /* Write the CR/LF pair.
         */
        eRc = csv_PutChr( cbp, ASCII_CR );
        if( ERESULT_HAS_FAILED(eRc) )
            return( eRc );
        eRc = csv_PutChr( cbp, ASCII_LF );
        if( ERESULT_HAS_FAILED(eRc) )
            return( eRc );
        
        /* Return to caller.
         */
        return( ERESULT_SUCCESSFUL_COMPLETION );
    }
    
    
    
    
    //---------------------------------------------------------------
    //                      V a l i d a t e
    //---------------------------------------------------------------

    #ifdef NDEBUG
    #else
    bool            csv_Validate(
        CSV_DATA      *cbp
    )
    {
        if( cbp ) {
            if ( obj_IsKindOf(cbp,OBJ_IDENT_CSV) )
                ;
            else
                return false;
        }
        else
            return false;
        if( !(obj_getSize(cbp) >= sizeof(CSV_DATA)) )
            return false;

        // Return to caller.
        return true;
    }
    #endif


    
    
    
#ifdef	__cplusplus
}
#endif


